<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>2&nbsp; Algorithmen – Digitalisierung und Programmierung</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./part-representation.html" rel="next">
<link href="./problem-solving.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-8da5b4427184b79ecddefad3d342027e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Keine Treffer",
    "search-matching-documents-text": "Treffer",
    "search-copy-link-title": "Link in die Suche kopieren",
    "search-hide-matches-text": "Zusätzliche Treffer verbergen",
    "search-more-match-text": "weitere Treffer in diesem Dokument",
    "search-more-matches-text": "weitere Treffer in diesem Dokument",
    "search-clear-button-title": "Zurücksetzen",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Abbrechen",
    "search-submit-button-title": "Abschicken",
    "search-label": "Suchen"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./part-problems.html">Probleme</a></li><li class="breadcrumb-item"><a href="./algorithms.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Algorithmen</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Seitenleiste umschalten" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Suchen" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Digitalisierung und Programmierung</a> 
        <div class="sidebar-tools-main">
    <a href="./book_digitalisierung_und_programmierung.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Suchen"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Vorwort</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lifi-project.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Das LiFi-Projekt</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./part-problems.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Probleme</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./problem-solving.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Problemlösung</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./algorithms.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Algorithmen</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./part-representation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Repräsentation</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./information.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Informationen</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./bits.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Bits</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./code-systems.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Codesysteme</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./data-structures.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Datenstrukturen</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./part-processing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Verarbeitung</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./analog-vs-digital.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Analog vs.&nbsp;Digital</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./storage.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Speicher</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./logic-and-arithmetic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Logik und Arithmetik</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./computer.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Computer</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./part-communication.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Kommunikation</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./signals.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Signale</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./protocols.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Protokolle</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./encryption.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Verschlüsselung</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./compression.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Kompression</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./part-programming.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Programmierung</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Abschnitt umschalten">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./welcome-to-python.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Willkommen in Python</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./variables-and-data-types.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Variablen und Datentypen</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./functions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">Funktionen</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./collections.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Collections</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./conditionals.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Kontrollstrukturen</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./loops.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Schleifen</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./debugging-and-error-handling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">21</span>&nbsp; <span class="chapter-title">Fehlersuche- und Behandlung</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Literaturverzeichnis</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Inhaltsverzeichnis</h2>
   
  <ul>
  <li><a href="#zusammenfassung" id="toc-zusammenfassung" class="nav-link active" data-scroll-target="#zusammenfassung">Zusammenfassung</a></li>
  <li><a href="#was-ist-ein-algorithmus" id="toc-was-ist-ein-algorithmus" class="nav-link" data-scroll-target="#was-ist-ein-algorithmus"><span class="header-section-number">2.1</span> Was ist ein Algorithmus?</a>
  <ul class="collapse">
  <li><a href="#herkunft-des-begriffs" id="toc-herkunft-des-begriffs" class="nav-link" data-scroll-target="#herkunft-des-begriffs"><span class="header-section-number">2.1.1</span> Herkunft des Begriffs</a></li>
  <li><a href="#algorithmen-und-programme" id="toc-algorithmen-und-programme" class="nav-link" data-scroll-target="#algorithmen-und-programme"><span class="header-section-number">2.1.2</span> Algorithmen und Programme</a></li>
  </ul></li>
  <li><a href="#wie-stellen-wir-algorithmen-dar" id="toc-wie-stellen-wir-algorithmen-dar" class="nav-link" data-scroll-target="#wie-stellen-wir-algorithmen-dar"><span class="header-section-number">2.2</span> Wie stellen wir Algorithmen dar?</a>
  <ul class="collapse">
  <li><a href="#natürliche-sprache" id="toc-natürliche-sprache" class="nav-link" data-scroll-target="#natürliche-sprache"><span class="header-section-number">2.2.1</span> Natürliche Sprache</a></li>
  <li><a href="#pseudocode" id="toc-pseudocode" class="nav-link" data-scroll-target="#pseudocode"><span class="header-section-number">2.2.2</span> Pseudocode</a></li>
  <li><a href="#flussdiagramme" id="toc-flussdiagramme" class="nav-link" data-scroll-target="#flussdiagramme"><span class="header-section-number">2.2.3</span> Flussdiagramme</a></li>
  </ul></li>
  <li><a href="#welche-arten-von-algorithmen-gibt-es" id="toc-welche-arten-von-algorithmen-gibt-es" class="nav-link" data-scroll-target="#welche-arten-von-algorithmen-gibt-es"><span class="header-section-number">2.3</span> Welche Arten von Algorithmen gibt es?</a>
  <ul class="collapse">
  <li><a href="#mathematische-algorithmen" id="toc-mathematische-algorithmen" class="nav-link" data-scroll-target="#mathematische-algorithmen"><span class="header-section-number">2.3.1</span> Mathematische Algorithmen</a></li>
  <li><a href="#suchalgorithmen" id="toc-suchalgorithmen" class="nav-link" data-scroll-target="#suchalgorithmen"><span class="header-section-number">2.3.2</span> Suchalgorithmen</a></li>
  <li><a href="#sortieralgorithmen" id="toc-sortieralgorithmen" class="nav-link" data-scroll-target="#sortieralgorithmen"><span class="header-section-number">2.3.3</span> Sortieralgorithmen</a></li>
  <li><a href="#optimierungsalgorithmen" id="toc-optimierungsalgorithmen" class="nav-link" data-scroll-target="#optimierungsalgorithmen"><span class="header-section-number">2.3.4</span> Optimierungsalgorithmen</a></li>
  <li><a href="#graphenalgorithmen" id="toc-graphenalgorithmen" class="nav-link" data-scroll-target="#graphenalgorithmen"><span class="header-section-number">2.3.5</span> Graphenalgorithmen</a></li>
  <li><a href="#stochastische-algorithmen" id="toc-stochastische-algorithmen" class="nav-link" data-scroll-target="#stochastische-algorithmen"><span class="header-section-number">2.3.6</span> Stochastische Algorithmen</a></li>
  <li><a href="#maschinelle-lernalgorithmen" id="toc-maschinelle-lernalgorithmen" class="nav-link" data-scroll-target="#maschinelle-lernalgorithmen"><span class="header-section-number">2.3.7</span> Maschinelle Lernalgorithmen</a></li>
  </ul></li>
  <li><a href="#welche-wichtigen-algorithmischen-denkmuster-gibt-es" id="toc-welche-wichtigen-algorithmischen-denkmuster-gibt-es" class="nav-link" data-scroll-target="#welche-wichtigen-algorithmischen-denkmuster-gibt-es"><span class="header-section-number">2.4</span> Welche wichtigen algorithmischen Denkmuster gibt es?</a>
  <ul class="collapse">
  <li><a href="#sequenzen" id="toc-sequenzen" class="nav-link" data-scroll-target="#sequenzen"><span class="header-section-number">2.4.1</span> Sequenzen</a></li>
  <li><a href="#verzweigungen" id="toc-verzweigungen" class="nav-link" data-scroll-target="#verzweigungen"><span class="header-section-number">2.4.2</span> Verzweigungen</a></li>
  <li><a href="#iterationen" id="toc-iterationen" class="nav-link" data-scroll-target="#iterationen"><span class="header-section-number">2.4.3</span> Iterationen</a></li>
  <li><a href="#kapselung" id="toc-kapselung" class="nav-link" data-scroll-target="#kapselung"><span class="header-section-number">2.4.4</span> Kapselung</a></li>
  <li><a href="#rekursion" id="toc-rekursion" class="nav-link" data-scroll-target="#rekursion"><span class="header-section-number">2.4.5</span> Rekursion</a></li>
  </ul></li>
  <li><a href="#was-sind-herausforderungen-bei-der-fomulierung-von-algorithmen" id="toc-was-sind-herausforderungen-bei-der-fomulierung-von-algorithmen" class="nav-link" data-scroll-target="#was-sind-herausforderungen-bei-der-fomulierung-von-algorithmen"><span class="header-section-number">2.5</span> Was sind Herausforderungen bei der Fomulierung von Algorithmen?</a>
  <ul class="collapse">
  <li><a href="#sec-algo-halt" id="toc-sec-algo-halt" class="nav-link" data-scroll-target="#sec-algo-halt"><span class="header-section-number">2.5.1</span> Haltekriterium</a></li>
  <li><a href="#sec-algo-infinity" id="toc-sec-algo-infinity" class="nav-link" data-scroll-target="#sec-algo-infinity"><span class="header-section-number">2.5.2</span> Endlosschleifen</a></li>
  <li><a href="#beurteilung-des-ergebnisses" id="toc-beurteilung-des-ergebnisses" class="nav-link" data-scroll-target="#beurteilung-des-ergebnisses"><span class="header-section-number">2.5.3</span> Beurteilung des Ergebnisses</a></li>
  <li><a href="#erklärbarkeit-des-ergebnisses" id="toc-erklärbarkeit-des-ergebnisses" class="nav-link" data-scroll-target="#erklärbarkeit-des-ergebnisses"><span class="header-section-number">2.5.4</span> Erklärbarkeit des Ergebnisses</a></li>
  </ul></li>
  <li><a href="#gibt-es-bessere-und-schlechtere-algorithmen" id="toc-gibt-es-bessere-und-schlechtere-algorithmen" class="nav-link" data-scroll-target="#gibt-es-bessere-und-schlechtere-algorithmen"><span class="header-section-number">2.6</span> Gibt es bessere und schlechtere Algorithmen?</a>
  <ul class="collapse">
  <li><a href="#komplexität" id="toc-komplexität" class="nav-link" data-scroll-target="#komplexität"><span class="header-section-number">2.6.1</span> Komplexität</a></li>
  <li><a href="#verständlichkeit" id="toc-verständlichkeit" class="nav-link" data-scroll-target="#verständlichkeit"><span class="header-section-number">2.6.2</span> Verständlichkeit</a></li>
  </ul></li>
  <li><a href="#übungsaufgaben" id="toc-übungsaufgaben" class="nav-link" data-scroll-target="#übungsaufgaben">Übungsaufgaben</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./part-problems.html">Probleme</a></li><li class="breadcrumb-item"><a href="./algorithms.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Algorithmen</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span id="sec-algorithms" class="quarto-section-identifier"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Algorithmen</span></span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="zusammenfassung" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="zusammenfassung">Zusammenfassung</h2>
<p>Algorithmen sind ein fundamentales Konzept der Informatik und der digitalen Problemlösung. In diesem Kapitel befassen wir uns mit den grundlegenden Aspekten von Algorithmen und beantworten dabei zentrale Fragen:</p>
<ul>
<li>Was ist ein Algorithmus und wie grenzt er sich von einem Computerprogramm ab?</li>
<li>Wie könne wir Algorithmen darstellen?</li>
<li>Welche verschiedenen Arten von Algorithmen existieren und durch welche Beispiele lassen sie sich veranschaulichen?</li>
<li>Wie können wir Algorithmen systematisch und präzise formulieren?</li>
<li>Welche Herausforderungen begegnen uns beim Entwurf von Algorithmen?</li>
<li>Nach welchen Kriterien bewerten wir die Effizienz und Eignung verschiedener Algorithmen für spezifische Problemstellungen?</li>
</ul>
</section>
<section id="was-ist-ein-algorithmus" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="was-ist-ein-algorithmus"><span class="header-section-number">2.1</span> Was ist ein Algorithmus?</h2>
<section id="herkunft-des-begriffs" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="herkunft-des-begriffs"><span class="header-section-number">2.1.1</span> Herkunft des Begriffs</h3>
<p>Der Begriff “<strong>Algorithmus</strong>” <a href="https://www.wissenschaftsjahr.de/2008/coremedia/generator/wj2008/de/02__Mathematik__alles__was__z_C3_A4hlt/05__KW50__Algorithmus.html">stammt vom Namen des persischen Mathematikers Muhammad al-Khwarizmi</a>, der um das Jahr 780 n.&nbsp;Chr. geboren wurde. Al-Khwarizmi war ein bedeutender Gelehrter am Hofe des Kalifen al-Mamun und verfasste dort Schriften, die den Gebrauch der indischen Zahlzeichen erklärten. Diese Schriften wurden im 12. Jahrhundert ins Lateinische übersetzt, wobei der Titel “Algoritmi de numero Indorum” verwendet wurde. Im Laufe der Zeit wurde der Name al-Khwarizmi zur Bezeichnung für die von ihm beschriebenen Rechenverfahren und entwickelte sich schließlich zum modernen Begriff “Algorithmus”.</p>
<p>Heute bezeichnet ein <strong>Algorithmus</strong> eine präzise Abfolge von Anweisungen, die ein bestimmtes Problem lösen oder eine Aufgabe erfüllen sollen. Im Alltag begegnen uns Algorithmen ständig, oft, ohne dass wir es merken: beim Kochen, bei der Wegbeschreibung oder beim Aufbau eines IKEA-Regals.</p>
</section>
<section id="algorithmen-und-programme" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="algorithmen-und-programme"><span class="header-section-number">2.1.2</span> Algorithmen und Programme</h3>
<p>Ein wichtiger Aspekt von Algorithmen ist ihre Universalität: Sie sind nicht an Computer gebunden. Ein Algorithmus ist im Kern eine strukturierte Anleitung zur Problemlösung, unabhängig davon, wer oder was diese Anleitung ausführt. Diese Flexibilität zeigt sich besonders deutlich in unserem Alltag, wo wir ständig algorithmische Anleitungen befolgen - sei es beim Aufbau eines Möbelstücks oder beim Kochen nach einem Rezept. Bei diesen Tätigkeiten führen wir Menschen die algorithmischen Schritte aus, ganz ohne Beteiligung eines Computers:</p>
<ul>
<li>Kochen: Ein Rezept ist ein Algorithmus für die Zubereitung eines Gerichts.</li>
<li>Wegbeschreibung: Eine Schritt-für-Schritt-Anleitung, um von Punkt A nach Punkt B zu gelangen.</li>
<li>Bastelanleitung: Die Anweisungen, um ein Modellflugzeug zusammenzubauen.</li>
</ul>
<p>Viele Algorithmen können von Computern ausgeführt werden. Dafür ist jedoch eine Übersetzung in eine maschinenverständliche Form notwendig. Diese Übersetzung erfolgt durch das Programmieren, wobei wir den Algorithmus in einer Programmiersprache formulieren. Um die Beziehung zwischen Algorithmen und Computerprogrammen besser zu verstehen, ist es hilfreich, drei zentrale Begriffe zu unterscheiden:</p>
<ul>
<li><strong>Algorithmus</strong>: Die abstrakte Beschreibung einer Lösungsmethode in Form einer präzisen, endlichen Sequenz von individuellen Anweisungen. Ein Algorithmus ist unabhängig von der konkreten Umsetzung und kann sowohl von Menschen als auch von Maschinen ausgeführt werden.</li>
<li><strong>Programm</strong>: Die konkrete Implementation eines oder mehrerer Algorithmen in einer Programmiersprache. Das Programm übersetzt die abstrakten Anweisungen des Algorithmus in eine Form, die ein Computer verstehen und ausführen kann.</li>
<li><strong>Prozess</strong>: Die tatsächliche Ausführung eines Programms durch einen Computer. Dabei werden die programmierten Anweisungen Schritt für Schritt abgearbeitet, um das gewünschte Ergebnis zu erzielen.</li>
</ul>
<p>Im Folgenden konzentrieren wir uns zunächst auf das Konzept des Algorithmus an sich. Die praktische Implementierung in Form von Programmen werden wir später am Beispiel der Programmiersprache Python kennenlernen. Um Algorithmen jedoch bereits jetzt systematisch beschreiben und analysieren zu können, benötigen wir geeignete Darstellungsformen und Notationen.</p>
</section>
</section>
<section id="wie-stellen-wir-algorithmen-dar" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="wie-stellen-wir-algorithmen-dar"><span class="header-section-number">2.2</span> Wie stellen wir Algorithmen dar?</h2>
<section id="natürliche-sprache" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1" class="anchored" data-anchor-id="natürliche-sprache"><span class="header-section-number">2.2.1</span> Natürliche Sprache</h3>
<p>Die natürliche Sprache bietet eine intuitive Möglichkeit, Algorithmen zu beschreiben. Ein klassisches Beispiel hierfür sind Kochrezepte, die als informelle algorithmische Beschreibungen verstanden werden können. Diese Art der Darstellung folgt keinen festgelegten Regeln - jeder Autor kann die Anweisungen nach eigenem Ermessen formulieren. Entscheidend ist dabei nur, dass andere Menschen die Beschreibung <em>lesen</em> und <em>verstehen</em> können.</p>
<p>Für die professionelle Informatik ist diese informelle Darstellungsform jedoch nur bedingt geeignet. Während handschriftliche oder natürlichsprachliche Notizen für erste Entwürfe und Skizzen durchaus nützlich sein können, erfordern die präzise Dokumentation und der fachliche Austausch über Algorithmen eine formellere Notation.</p>
<p>Die natürliche Sprache weist für die präzise Beschreibung von Algorithmen zwei wesentliche Nachteile auf. Erstens ist sie mehrdeutig: Wörter und Sätze können je nach Kontext und Formulierung unterschiedlich interpretiert werden. Zweitens ist sie oft unnötig ausführlich, was die klare und effiziente Kommunikation von Algorithmen erschwert. Um diese Herausforderungen zu bewältigen, haben sich in der Informatik zwei formellere und präzisere Darstellungsformen durchgesetzt: Pseudocode und Flussdiagramme.</p>
</section>
<section id="pseudocode" class="level3" data-number="2.2.2">
<h3 data-number="2.2.2" class="anchored" data-anchor-id="pseudocode"><span class="header-section-number">2.2.2</span> Pseudocode</h3>
<p>Pseudocode ist eine strukturierte, programmiersprachenähnliche Notation zur Beschreibung von Algorithmen. Er kombiniert Elemente der natürlichen Sprache mit grundlegenden Programmierkonzepten wie Schleifen, Bedingungen und Funktionen. Der Vorteil des Pseudocodes liegt in seiner Präzision und Klarheit, ohne dabei an die strengen syntaktischen Regeln einer echten Programmiersprache gebunden zu sein.</p>
<p>Ein wichtiges Merkmal des Pseudocodes ist seine Flexibilität: Er kann je nach Bedarf formeller oder informeller gestaltet werden, solange die grundlegende Logik und Struktur des Algorithmus klar erkennbar bleiben. Dabei werden häufig standardisierte Schlüsselwörter wie “IF”, “THEN”, “WHILE” oder “REPEAT” verwendet, die die algorithmische Struktur verdeutlichen.</p>
<div id="fig-pseudocode-gcd" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-pseudocode-gcd-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/algorithms_pseudocode_example.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Abbildung&nbsp;2.1: Der Euklid’sche Algorithmus als Pseudocode."><img src="https://winf-hsos.github.io/university-docs/images/algorithms_pseudocode_example.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pseudocode-gcd-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;2.1: Der Euklid’sche Algorithmus als Pseudocode.
</figcaption>
</figure>
</div>
</section>
<section id="flussdiagramme" class="level3" data-number="2.2.3">
<h3 data-number="2.2.3" class="anchored" data-anchor-id="flussdiagramme"><span class="header-section-number">2.2.3</span> Flussdiagramme</h3>
<p>Flussdiagramme bieten eine visuelle Darstellung von Algorithmen durch standardisierte grafische Symbole und Verbindungslinien. Diese Notation ist besonders hilfreich, um den Ablauf eines Algorithmus und die logischen Verzweigungen auf einen Blick zu erfassen. <a href="#fig-flow-diagram-notation" class="quarto-xref">Abbildung&nbsp;<span>2.2</span></a> zeigt die wichtigsten Elemente eines Flussdiagramms: Start- und Endpunkte, Ein- und Ausgaben (Parallelogramm), Anweisungen (Rechteck), Entscheidungen (Rauten), Wiederholungen (Sechseck).</p>
<div id="fig-flow-diagram-notation" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-flow-diagram-notation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/algorithms_flow_diagram_notation.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Abbildung&nbsp;2.2: Die Notationselemente des Flussdiagramms."><img src="https://winf-hsos.github.io/university-docs/images/algorithms_flow_diagram_notation.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-flow-diagram-notation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;2.2: Die Notationselemente des Flussdiagramms.
</figcaption>
</figure>
</div>
<p>Dazu kommen Verbindungspfeile, die den Kontrollfluss anzeigen. Diese sind im Beispiel in <a href="#fig-euclid-flow" class="quarto-xref">Abbildung&nbsp;<span>2.3</span></a> zu sehen.</p>
<div id="fig-euclid-flow" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-euclid-flow-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/algorithms_flow_diagram_gcd.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Abbildung&nbsp;2.3: Der Euklid’sche Algorithmus als Flussdiagramm."><img src="https://winf-hsos.github.io/university-docs/images/algorithms_flow_diagram_gcd.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-euclid-flow-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;2.3: Der Euklid’sche Algorithmus als Flussdiagramm.
</figcaption>
</figure>
</div>
</section>
</section>
<section id="welche-arten-von-algorithmen-gibt-es" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="welche-arten-von-algorithmen-gibt-es"><span class="header-section-number">2.3</span> Welche Arten von Algorithmen gibt es?</h2>
<p>Algorithmen können nach ihrer Funktion und ihrem Anwendungsbereich in verschiedene Kategorien eingeteilt werden. Jede Kategorie repräsentiert einen spezifischen Problemlösungsansatz:</p>
<ul>
<li><strong>Mathematische Algorithmen</strong>: Berechnen oder approximieren Werte</li>
<li><strong>Suchalgorithmen</strong>: Finden bestimmte Elemente in einer Datenmenge</li>
<li><strong>Sortieralgorithmen</strong>: Ordnen Daten nach bestimmten Kriterien</li>
<li><strong>Optimierungsalgorithmen</strong>: Finden die bestmögliche Lösung für ein Problem</li>
<li><strong>Graphenalgorithmen</strong>: Arbeiten mit vernetzten Strukturen</li>
<li><strong>Stochastische Algorithmen</strong>: Verwenden Zufallselemente, um ein Problem zu lösen</li>
<li><strong>Maschinelle Lernalgorithmen</strong>: Erkennen Muster und treffen Vorhersagen</li>
</ul>
<p>Diese Kategorien sind weder vollständig noch strikt voneinander getrennt. Viele Algorithmen lassen sich mehreren Kategorien zuordnen. Ein anschauliches Beispiel hierfür ist der <strong>Dijkstra-Algorithmus</strong>, der die kürzeste Route zwischen zwei Punkten findet. Er ist sowohl ein Graphenalgorithmus, da er auf vernetzten Strukturen arbeitet, als auch ein Optimierungsalgorithmus, da er die optimale (kürzeste) Route ermittelt.</p>
<p>Im folgenden beleuchten wir ein oder mehr Beispiele für jeder der genannten Klassen.</p>
<section id="mathematische-algorithmen" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1" class="anchored" data-anchor-id="mathematische-algorithmen"><span class="header-section-number">2.3.1</span> Mathematische Algorithmen</h3>
<section id="größter-gemeinsamer-teiler-ggt" class="level4" data-number="2.3.1.1">
<h4 data-number="2.3.1.1" class="anchored" data-anchor-id="größter-gemeinsamer-teiler-ggt"><span class="header-section-number">2.3.1.1</span> Größter gemeinsamer Teiler (GGT)</h4>
<p>Der Algorithmus zur Berechnung des größten gemeinsamen Teilers (GGT) ist ein klassisches Beispiel für einen eleganten mathematischen Algorithmus. Er wurde vom griechischen Mathematiker Euklid um 300 v. Chr. in seinem Werk “Die Elemente” beschrieben und demonstriert eindrucksvoll die zeitlose Natur algorithmischen Denkens.</p>
<div id="fig-euclid-algo" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-euclid-algo-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/algorithms_euclidean_textual.png" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="Abbildung&nbsp;2.4: Vorgehen des Algorithmus nach Euklid."><img src="https://winf-hsos.github.io/university-docs/images/algorithms_euclidean_textual.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-euclid-algo-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;2.4: Vorgehen des Algorithmus nach Euklid.
</figcaption>
</figure>
</div>
<p>Das Verfahren basiert auf einem einfachen, aber genialen Prinzip: Der GGT zweier Zahlen ist identisch mit dem GGT der kleineren Zahl und der Differenz beider Zahlen (<a href="#fig-euclid-algo" class="quarto-xref">Abbildung&nbsp;<span>2.4</span></a>). Zum Beispiel haben die Zahlen 48 und 18 den gleichen GGT wie 18 und 30 (48-18). Durch wiederholtes Anwenden dieser Regel wird der GGT systematisch ermittelt. Die Eleganz dieses Verfahrens liegt in seiner Einfachheit und mathematischen Präzision - Eigenschaften, die auch heute noch moderne Algorithmen auszeichnen.</p>
<p><a href="#fig-euclidean-example" class="quarto-xref">Abbildung&nbsp;<span>2.5</span></a> zeigt die Schritte des Euklidschen Algorithmus für das obige Zahlenbeispiel.</p>
<div id="fig-euclidean-example" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-euclidean-example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/algorithms_euclidean_example.png" class="lightbox" data-gallery="quarto-lightbox-gallery-5" title="Abbildung&nbsp;2.5: Beispiel für die Anwendung des Algorithmus nach Euklid."><img src="https://winf-hsos.github.io/university-docs/images/algorithms_euclidean_example.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-euclidean-example-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;2.5: Beispiel für die Anwendung des Algorithmus nach Euklid.
</figcaption>
</figure>
</div>
</section>
<section id="sec-babylonian" class="level4" data-number="2.3.1.2">
<h4 data-number="2.3.1.2" class="anchored" data-anchor-id="sec-babylonian"><span class="header-section-number">2.3.1.2</span> Babylonisches Wurzelziehen</h4>
<p>Das Babylonische Verfahren zur Berechnung der Quadratwurzel ist ein weiteres Beispiel für einen mathematischen Algorithmus. Während der Euklid’sche Algorithmus exakte Ergebnisse liefert, zeigt das Babylonische Verfahren eine andere wichtige Eigenschaft mathematischer Algorithmen: <strong>die schrittweise Annäherung an einen Zielwert</strong>. Der Algorithmus <em>approximiert</em> die Quadratwurzel durch wiederholte Verfeinerung der Schätzung und <em>konvergiert</em> dabei gegen den tatsächlichen Wert. Diese Methode demonstriert, wie auch ohne exakte Berechnung präzise Ergebnisse erzielt werden können.</p>
<p>Ein anschauliches Beispiel für das Babylonische Verfahren ist in <a href="#fig-babylonian-1" class="quarto-xref">Abbildung&nbsp;<span>2.6</span></a> dargestellt. Der Algorithmus berechnet die Quadratwurzel einer Eingabezahl durch geometrische Annäherung: Wenn wir die Eingabezahl <span class="math inline">\(x\)</span> als Flächeninhalt eines Rechtecks interpretieren, suchen wir die Seitenlängen eines Quadrats mit der gleichen Fläche.</p>
<p>Das Verfahren nähert sich diesem Wert schrittweise an, indem es die Seitenlängen <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> eines Rechtecks iterativ anpasst. Nehmen wir an, wir wollen die Quadratwurzel aus <span class="math inline">\(x = 16\)</span> ziehen. Zu Beginn setzen wir <span class="math inline">\(A = 1\)</span> und berechnen <span class="math inline">\(B\)</span> so, dass das Produkt der Seitenlängen die gesuchte Fläche ergibt: <span class="math inline">\(B = \frac{x}{A} = 16\)</span>. Dieser Ausgangszustand ist in <a href="#fig-babylonian-1" class="quarto-xref">Abbildung&nbsp;<span>2.6</span></a> dargestellt.</p>
<div id="fig-babylonian-1" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-babylonian-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/algorithms_example_babylonian_1.png" class="lightbox" data-gallery="quarto-lightbox-gallery-6" title="Abbildung&nbsp;2.6: Ausgangszustand im Babylonischen Wurzelziehen."><img src="https://winf-hsos.github.io/university-docs/images/algorithms_example_babylonian_1.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-babylonian-1-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;2.6: Ausgangszustand im Babylonischen Wurzelziehen.
</figcaption>
</figure>
</div>
<p>Nach der Festlegung der Startwerte beginnt der eigentliche iterative Prozess der Annäherung. In jedem Durchlauf werden die Werte für <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> nach spezifischen Formeln neu berechnet, wodurch sie sich schrittweise einander annähern:</p>
<p><span class="math display">\[
A = \frac{A+B}{2}
\]</span></p>
<p>Und damit die Gesamtfläche der gesuchten Zahl <span class="math inline">\(x\)</span> entspricht, setzen wir <span class="math inline">\(B\)</span> wie folgt:</p>
<p><span class="math display">\[
B= \frac{x}{A}
\]</span></p>
<p>Wenden wir diese Formeln auf unsere Ausgangswerte an, ergibt sich für den zweiten Iterationsschritt das in <a href="#fig-babylonian-2" class="quarto-xref">Abbildung&nbsp;<span>2.7</span></a> visualisierte Rechteck. Hier berechnen wir zunächst die neue Länge A:</p>
<p><span class="math display">\[
A = \frac{1 + 16}{2} = 8.5
\]</span></p>
<p>Und daraus folgt für B:</p>
<p><span class="math display">\[
B = \frac{16}{8.5} \approx 1.88
\]</span></p>
<div id="fig-babylonian-2" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-babylonian-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/algorithms_example_babylonian_2.png" class="lightbox" data-gallery="quarto-lightbox-gallery-7" title="Abbildung&nbsp;2.7: Zustand des Babylonischen Verfahrens nach dem ersten Schritt."><img src="https://winf-hsos.github.io/university-docs/images/algorithms_example_babylonian_2.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-babylonian-2-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;2.7: Zustand des Babylonischen Verfahrens nach dem ersten Schritt.
</figcaption>
</figure>
</div>
<p>Verglichen mit dem Ausgangszustand haben sich die Werte <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> bereits angenähert, aber sie weichen noch deutlich voneinander ab. Um eine bessere Approximation zu erreichen, führen wir eine weitere Iteration durch und berechnen die neuen Werte für <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> nach dem etablierten Schema:</p>
<p><span class="math display">\[
A = \frac{8.5 + 1.88}{2} \approx 5.19
\]</span></p>
<p>Und für die andere Kante:</p>
<p><span class="math display">\[
B = \frac{16}{5.19} \approx 3.08
\]</span></p>
<div id="fig-babylonian-3" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-babylonian-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/algorithms_example_babylonian_3.png" class="lightbox" data-gallery="quarto-lightbox-gallery-8" title="Abbildung&nbsp;2.8: Zustand des Babylonischen Verfahrens nach dem zweiten Schritt."><img src="https://winf-hsos.github.io/university-docs/images/algorithms_example_babylonian_3.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-babylonian-3-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;2.8: Zustand des Babylonischen Verfahrens nach dem zweiten Schritt.
</figcaption>
</figure>
</div>
<p>Die Werte haben sich weiter angenähert. Da wir wissen, dass beide Kanten am Ende die Länge 4 haben sollen, ist eine weitere Iteration erforderlich. Nach der dritten Berechnung, wie in <a href="#fig-babylonian-4" class="quarto-xref">Abbildung&nbsp;<span>2.9</span></a> dargestellt, nähern sich beide Kanten bereits sehr präzise dem Zielwert von 4 an.</p>
<div id="fig-babylonian-4" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-babylonian-4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/algorithms_example_babylonian_4.png" class="lightbox" data-gallery="quarto-lightbox-gallery-9" title="Abbildung&nbsp;2.9: Zustand des Babylonischen Verfahrens nach dem dritten Schritt."><img src="https://winf-hsos.github.io/university-docs/images/algorithms_example_babylonian_4.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-babylonian-4-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;2.9: Zustand des Babylonischen Verfahrens nach dem dritten Schritt.
</figcaption>
</figure>
</div>
<p>Nach einer weiteren Iteration konvergiert der Algorithmus zum gesuchten Wert: Beide Seiten <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> erreichen durch Rundung den Wert 4. Damit haben wir das gesuchte Quadrat erfolgreich konstruiert, und der Algorithmus kann beendet werden.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://winf-hsos.github.io/university-docs/images/algorithms_example_babylonian_5.png" class="lightbox" data-gallery="quarto-lightbox-gallery-10"><img src="https://winf-hsos.github.io/university-docs/images/algorithms_example_babylonian_5.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></a></p>
</figure>
</div>
<p>In diesem Beispiel konvergiert der Algorithmus bereits nach wenigen Iterationen zum korrekten Ergebnis. Die Geschwindigkeit der Konvergenz hängt jedoch von zwei wesentlichen Faktoren ab:</p>
<ol type="1">
<li>Der Eingabezahl, aus der die Wurzel gezogen werden soll</li>
<li>Der Wahl der Startwerte für <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span></li>
</ol>
<p>Je nach Konstellation dieser Faktoren kann die Annäherung deutlich mehr Iterationen benötigen. Zudem erreichen die beiden Seiten in vielen Fällen keine exakte Gleichheit, sondern nähern sich lediglich bis auf eine beliebig kleine Differenz an. Dies wirft eine wichtige praktische Frage auf: Wann ist die Approximation der Quadratwurzel präzise genug, um den Algorithmus zu beenden? Dazu später in <a href="#sec-algo-halt" class="quarto-xref"><span>Kapitel 2.5.1</span></a> mehr.</p>
<p>Ein pragmatisches Abbruchkriterium für das Babylonische Verfahren ist das Erreichen einer vordefinierten Genauigkeit. Nach jedem Iterationsschritt wird die Differenz zwischen den Werten <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> berechnet. Ist diese Differenz kleiner als ein festgelegter Schwellenwert, wird der Algorithmus beendet. Der vollständige Ablauf des Verfahrens ist in <a href="#fig-babylonian-flow" class="quarto-xref">Abbildung&nbsp;<span>2.10</span></a> dargestellt.</p>
<div id="fig-babylonian-flow" class="lightbox quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-babylonian-flow-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="https://winf-hsos.github.io/university-docs/images/algorithms_flow_diagram_babylonian.png" class="lightbox" data-gallery="quarto-lightbox-gallery-11" title="Abbildung&nbsp;2.10: Das Babylonische Verfahren als Flussdiagramm."><img src="https://winf-hsos.github.io/university-docs/images/algorithms_flow_diagram_babylonian.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:100.0%"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-babylonian-flow-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Abbildung&nbsp;2.10: Das Babylonische Verfahren als Flussdiagramm.
</figcaption>
</figure>
</div>
<p>Das Flussdiagramm beginnt auf der linken Seite mit einer Eingabeprüfung: Die Zahl <span class="math inline">\(x\)</span> wird eingelesen und auf Positivität getestet, da die Quadratwurzel aus negativen Zahlen nicht definiert ist. Eine Verzweigung überprüft die Bedingung <span class="math inline">\(x &gt; 0\)</span> und leitet den Algorithmus entsprechend weiter. Bei positiver Eingabe werden die Startwerte für <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> initialisiert. Anschließend beginnt eine WHILE-Schleife, die solange durchlaufen wird, bis die Differenz zwischen <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> einen definierten Schwellenwert unterschreitet. Nach erfolgreicher Konvergenz wird der finale Wert von <span class="math inline">\(A\)</span> als Ergebnis ausgegeben.</p>
<p>Eine weitere wichtige Frage bei der Entwicklung von Algorithmen betrifft deren Terminierung: Wir müssen nicht nur festlegen, wann ein Algorithmus beendet werden soll, sondern auch sicherstellen, dass er überhaupt ein Ende erreicht. Am Beispiel des Babylonischen Verfahrens lässt sich dies gut veranschaulichen: Die entscheidende Frage ist, ob die Werte <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> tatsächlich konvergieren, also sich einander systematisch annähern.</p>
<p>In diesem Fall können wir die Frage positiv beantworten. Die Berechnungsformel, die in jedem Schritt den neuen Wert für <span class="math inline">\(A\)</span> als Durchschnitt aus <span class="math inline">\(A\)</span> und <span class="math inline">\(B\)</span> bestimmt, garantiert eine stetige Annäherung der beiden Werte. Diese mathematische Eigenschaft sichert die Terminierung des Algorithmus. Bei anderen Algorithmen muss die Terminierung jedoch sorgfältig analysiert werden, um unendliche Ausführungen zu vermeiden. Mehr dazu in <a href="#sec-algo-infinity" class="quarto-xref"><span>Kapitel 2.5.2</span></a>.</p>
</section>
</section>
<section id="suchalgorithmen" class="level3" data-number="2.3.2">
<h3 data-number="2.3.2" class="anchored" data-anchor-id="suchalgorithmen"><span class="header-section-number">2.3.2</span> Suchalgorithmen</h3>
<p>Nach der Betrachtung mathematischer Algorithmen wenden wir uns nun den Suchalgorithmen zu - einer fundamentalen Kategorie von Algorithmen, die ein essentielles Element der Informatikausbildung darstellt. Diese Algorithmen bilden die Grundlage für effiziente Datenzugriffe und sind damit von großer praktischer Bedeutung.</p>
<section id="lineare-suche" class="level4" data-number="2.3.2.1">
<h4 data-number="2.3.2.1" class="anchored" data-anchor-id="lineare-suche"><span class="header-section-number">2.3.2.1</span> Lineare Suche</h4>
<p>Die lineare Suche ist der einfachste Suchalgorithmus und folgt einem intuitiven Ansatz: Sie durchläuft eine Liste sequentiell von Anfang bis Ende, bis das gesuchte Element gefunden wird. Obwohl dieser Algorithmus konzeptionell sehr einfach ist, hat er den Nachteil einer relativ hohen Laufzeit, da im schlechtesten Fall die gesamte Liste durchsucht werden muss. Dennoch ist die lineare Suche für unsortierte Listen oder kleine Datenmengen eine praktikable Lösung.</p>
</section>
<section id="binäre-suche" class="level4" data-number="2.3.2.2">
<h4 data-number="2.3.2.2" class="anchored" data-anchor-id="binäre-suche"><span class="header-section-number">2.3.2.2</span> Binäre Suche</h4>
<p>Die binäre Suche ist ein hocheffizienter Algorithmus, der auf dem “Teile und Herrsche”-Prinzip (Divide &amp; Conquer) basiert. Eine wichtige Voraussetzung für ihre Anwendung ist, dass die zu durchsuchende Liste sortiert vorliegt. Der Algorithmus arbeitet systematisch, indem er in jedem Schritt die Liste in der Mitte teilt und anhand eines Vergleichs entscheidet, ob sich das gesuchte Element im linken oder rechten Teilbereich befindet. Durch diese Halbierung des Suchbereichs in jedem Schritt erreicht die binäre Suche eine bemerkenswerte Effizienz.</p>
<p>Diese Strategie, die wir bereits im vorigen <a href="problem-solving.html#sec-divide-and-conquer" class="quarto-xref"><span>Kapitel 1.4.2</span></a> als <em>Divide-and- Conquer</em>-Ansatz kennengelernt haben, ermöglicht es der binären Suche, selbst in großen Datensätzen ein gesuchtes Element mit minimaler Anzahl von Vergleichsoperationen zu finden.</p>
</section>
<section id="suche-in-bäumen" class="level4" data-number="2.3.2.3">
<h4 data-number="2.3.2.3" class="anchored" data-anchor-id="suche-in-bäumen"><span class="header-section-number">2.3.2.3</span> Suche in Bäumen</h4>
<p>Die Suche in Baumstrukturen stellt eine weitere wichtige Variante der Suchalgorithmen dar. Binäre Suchbäume ermöglichen durch ihre hierarchische Struktur eine besonders effiziente Suche, da in jedem Knoten eine binäre Entscheidung getroffen wird, die den Suchbereich systematisch einschränkt. Diese Baumstrukturen kombinieren die Vorteile der binären Suche mit einer dynamischen Datenorganisation, die Einfüge- und Löschoperationen effizient unterstützt.</p>
</section>
</section>
<section id="sortieralgorithmen" class="level3" data-number="2.3.3">
<h3 data-number="2.3.3" class="anchored" data-anchor-id="sortieralgorithmen"><span class="header-section-number">2.3.3</span> Sortieralgorithmen</h3>
<p>Sortieralgorithmen bilden eine weitere fundamentale Kategorie von Algorithmen, die sich mit der systematischen Anordnung von Datenelementen in einer bestimmten Reihenfolge befassen. Die Bedeutung dieser Algorithmen liegt nicht nur in ihrer direkten Anwendung zur Sortierung von Daten, sondern auch in ihrer Rolle als Grundlage für effizientere Such- und Analyseverfahren. Im Folgenden betrachten wir drei klassische Sortieralgorithmen, die sich in ihrer Herangehensweise und Effizienz deutlich unterscheiden.</p>
<section id="bubblesort" class="level4" data-number="2.3.3.1">
<h4 data-number="2.3.3.1" class="anchored" data-anchor-id="bubblesort"><span class="header-section-number">2.3.3.1</span> Bubblesort</h4>
<p>Bubblesort ist ein einfacher Sortieralgorithmus, der paarweise benachbarte Elemente vergleicht und bei Bedarf vertauscht. Dieser Prozess wird solange wiederholt, bis keine Vertauschungen mehr notwendig sind und die Liste sortiert ist. Obwohl Bubblesort aufgrund seiner einfachen Implementierung und Verständlichkeit oft zu Lehrzwecken verwendet wird, ist er für große Datenmengen wegen seiner quadratischen Laufzeitkomplexität wenig effizient.</p>
</section>
<section id="selctionsort" class="level4" data-number="2.3.3.2">
<h4 data-number="2.3.3.2" class="anchored" data-anchor-id="selctionsort"><span class="header-section-number">2.3.3.2</span> Selctionsort</h4>
<p>Selectionsort ist ein weiterer elementarer Sortieralgorithmus, der die Liste schrittweise sortiert, indem er wiederholt das kleinste Element im unsortierten Teil der Liste findet und es an die korrekte Position im sortierten Teil verschiebt. Ähnlich wie Bubblesort ist auch dieser Algorithmus konzeptionell einfach zu verstehen, weist jedoch ebenfalls eine quadratische Laufzeitkomplexität auf. Der Vorteil gegenüber Bubblesort liegt in der geringeren Anzahl tatsächlicher Vertauschungsoperationen, da Elemente nur dann verschoben werden, wenn sie tatsächlich an ihre finale Position gebracht werden.</p>
</section>
<section id="mergesort" class="level4" data-number="2.3.3.3">
<h4 data-number="2.3.3.3" class="anchored" data-anchor-id="mergesort"><span class="header-section-number">2.3.3.3</span> Mergesort</h4>
<p>Mergesort ist ein effizienter Sortieralgorithmus, der auf dem Divide-and-Conquer-Prinzip basiert. Er teilt die zu sortierende Liste rekursiv in kleinere Teilsequenzen, bis diese nur noch ein Element enthalten, und führt diese dann schrittweise in sortierter Reihenfolge wieder zusammen. Im Gegensatz zu Bubblesort und Selectionsort erreicht Mergesort durch seine rekursive Strategie eine deutlich bessere Laufzeitkomplexität, was ihn besonders für große Datenmengen attraktiv macht.</p>
</section>
</section>
<section id="optimierungsalgorithmen" class="level3" data-number="2.3.4">
<h3 data-number="2.3.4" class="anchored" data-anchor-id="optimierungsalgorithmen"><span class="header-section-number">2.3.4</span> Optimierungsalgorithmen</h3>
<p>Optimierungsalgorithmen sind eine wichtige Klasse von Algorithmen, die darauf abzielen, die bestmögliche Lösung für ein gegebenes Problem zu finden. Diese Algorithmen sind besonders relevant in praktischen Anwendungen, wo optimale oder nahezu optimale Lösungen für komplexe Probleme gefunden werden müssen. Typische Beispiele finden sich in der Logistik, der Produktionsplanung oder der Ressourcenallokation. Die verschiedenen Ansätze zur Optimierung unterscheiden sich dabei hauptsächlich in ihrer Herangehensweise und Effizienz.</p>
<section id="brute-force" class="level4" data-number="2.3.4.1">
<h4 data-number="2.3.4.1" class="anchored" data-anchor-id="brute-force"><span class="header-section-number">2.3.4.1</span> Brute-Force</h4>
<p>Der Brute-Force-Ansatz ist die einfachste, aber auch rechenintensivste Methode der Optimierung. Dabei werden systematisch alle möglichen Lösungen durchprobiert, um die beste zu finden. Obwohl dieser Ansatz für kleine Probleme praktikabel sein kann, wird er bei wachsender Problemgröße schnell ineffizient, da die Anzahl der zu prüfenden Kombinationen exponentiell steigt.</p>
</section>
<section id="random-sampling" class="level4" data-number="2.3.4.2">
<h4 data-number="2.3.4.2" class="anchored" data-anchor-id="random-sampling"><span class="header-section-number">2.3.4.2</span> Random-Sampling</h4>
<p>Random-Sampling ist ein stochastischer Optimierungsansatz, der zufällig ausgewählte Lösungen aus dem Suchraum evaluiert. Im Gegensatz zur erschöpfenden Suche des Brute-Force-Verfahrens werden hier nur Stichproben untersucht, was den Rechenaufwand deutlich reduziert. Dieser Ansatz eignet sich besonders für große Suchräume, in denen eine vollständige Enumeration nicht praktikabel ist, kann aber nicht garantieren, das globale Optimum zu finden.</p>
</section>
<section id="evolutionäre-algorithmen" class="level4" data-number="2.3.4.3">
<h4 data-number="2.3.4.3" class="anchored" data-anchor-id="evolutionäre-algorithmen"><span class="header-section-number">2.3.4.3</span> Evolutionäre Algorithmen</h4>
<p>Evolutionäre Algorithmen sind Optimierungsverfahren, die auf den Prinzipien der biologischen Evolution basieren. Sie operieren mit einer Population von Lösungskandidaten und verbessern diese durch drei zentrale Mechanismen: Mutation (zufällige Veränderungen), Rekombination (Kombination erfolgreicher Lösungen) und Selektion (Auswahl der besten Varianten). Der iterative Prozess aus Variation und Auswahl führt schrittweise zu besseren Lösungen.</p>
<p>Diese Algorithmen sind besonders effektiv bei komplexen Optimierungsproblemen, für die keine exakten Lösungsmethoden existieren oder diese zu rechenintensiv wären. Da die Mutation der Lösungskandidaten auf Zufallsprozessen basiert, gehören evolutionäre Algorithmen zur Klasse der stochastischen Verfahren.</p>
</section>
<section id="bayessche-optimierung" class="level4" data-number="2.3.4.4">
<h4 data-number="2.3.4.4" class="anchored" data-anchor-id="bayessche-optimierung"><span class="header-section-number">2.3.4.4</span> Bayes’sche Optimierung</h4>
<p>Die Bayes’sche Optimierung ist ein effizienter Ansatz zur Optimierung von komplexen Funktionen, der auf dem Bayes’schen Theorem basiert. Anders als klassische Optimierungsverfahren nutzt dieser Algorithmus probabilistische Modelle, um die Zielfunktion zu approximieren und vielversprechende Bereiche des Suchraums zu identifizieren. Besonders nützlich ist dieser Ansatz bei rechenintensiven Problemen, bei denen jede Auswertung der Zielfunktion zeit- oder kostenaufwendig ist.</p>
</section>
</section>
<section id="graphenalgorithmen" class="level3" data-number="2.3.5">
<h3 data-number="2.3.5" class="anchored" data-anchor-id="graphenalgorithmen"><span class="header-section-number">2.3.5</span> Graphenalgorithmen</h3>
<section id="dijkstra-algorithmus" class="level4" data-number="2.3.5.1">
<h4 data-number="2.3.5.1" class="anchored" data-anchor-id="dijkstra-algorithmus"><span class="header-section-number">2.3.5.1</span> Dijkstra-Algorithmus</h4>
<p>Der Dijkstra-Algorithmus, entwickelt 1956 von Edsger W. Dijkstra, ist ein fundamentaler Algorithmus zur Berechnung kürzester Pfade in gewichteten Graphen. Seine Funktionsweise basiert auf dem Prinzip der schrittweisen Optimierung: Ausgehend von einem Startknoten berechnet er systematisch die kürzesten Wege zu allen anderen Knoten im Graphen. Aufgrund seiner Effizienz und Zuverlässigkeit findet der Algorithmus heute breite praktische Anwendung, insbesondere in der Routenplanung, Netzwerkanalyse und Logistik.</p>
</section>
<section id="das-traveling-salesman-problem" class="level4" data-number="2.3.5.2">
<h4 data-number="2.3.5.2" class="anchored" data-anchor-id="das-traveling-salesman-problem"><span class="header-section-number">2.3.5.2</span> Das Traveling Salesman-Problem</h4>
<p>Das Traveling Salesman-Problem (TSP) gehört zu den bekanntesten Optimierungsproblemen der Graphentheorie. Die Aufgabenstellung ist dabei einfach zu verstehen: Ein Handelsreisender muss eine Route planen, die alle vorgegebenen Städte genau einmal besucht und am Ende zum Ausgangspunkt zurückführt. Das Ziel ist es, die kürzeste mögliche Route zu finden. Trotz dieser scheinbar einfachen Formulierung ist das TSP ein NP-schweres Problem - das bedeutet, dass bisher kein Algorithmus gefunden wurde, der für große Städtemengen in angemessener Zeit die optimale Lösung garantiert berechnen kann.</p>
</section>
</section>
<section id="stochastische-algorithmen" class="level3" data-number="2.3.6">
<h3 data-number="2.3.6" class="anchored" data-anchor-id="stochastische-algorithmen"><span class="header-section-number">2.3.6</span> Stochastische Algorithmen</h3>
<section id="annäherung-der-kreiszahl-pi" class="level4" data-number="2.3.6.1">
<h4 data-number="2.3.6.1" class="anchored" data-anchor-id="annäherung-der-kreiszahl-pi"><span class="header-section-number">2.3.6.1</span> Annäherung der Kreiszahl <span class="math inline">\(\pi\)</span></h4>
<p>Die Monte-Carlo-Methode ist ein anschauliches Beispiel für stochastische Algorithmen. Sie nutzt Zufallszahlen zur Annäherung mathematischer Werte, wie etwa der Kreiszahl π. Das Verfahren platziert dabei zufällig Punkte in einem Quadrat mit einbeschriebenem Kreis. Das Verhältnis der Punkte innerhalb des Kreises zur Gesamtanzahl der Punkte ermöglicht eine Approximation von π. Ein wichtiges Merkmal dieser stochastischen Methode ist, dass die Genauigkeit der Berechnung mit der Anzahl der generierten Punkte steigt.</p>
</section>
</section>
<section id="maschinelle-lernalgorithmen" class="level3" data-number="2.3.7">
<h3 data-number="2.3.7" class="anchored" data-anchor-id="maschinelle-lernalgorithmen"><span class="header-section-number">2.3.7</span> Maschinelle Lernalgorithmen</h3>
<p>Maschinelles Lernen hat sich in den letzten Jahren zu einem der wichtigsten Bereiche der Algorithmenentwicklung entwickelt. Diese Algorithmenklasse bildet die technische Grundlage für viele praktische Anwendungen der Künstlichen Intelligenz (KI). Maschinelle Lernalgorithmen zeichnen sich dadurch aus, dass sie aus vorhandenen Daten Muster erkennen und auf dieser Basis Vorhersagen oder Entscheidungen treffen können.</p>
</section>
</section>
<section id="welche-wichtigen-algorithmischen-denkmuster-gibt-es" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="welche-wichtigen-algorithmischen-denkmuster-gibt-es"><span class="header-section-number">2.4</span> Welche wichtigen algorithmischen Denkmuster gibt es?</h2>
<section id="sequenzen" class="level3" data-number="2.4.1">
<h3 data-number="2.4.1" class="anchored" data-anchor-id="sequenzen"><span class="header-section-number">2.4.1</span> Sequenzen</h3>
<p>Die Sequenz ist das grundlegendste Muster in der Algorithmik. Sie beschreibt eine geordnete Abfolge von Anweisungen, die nacheinander ausgeführt werden. Wie bei einer Wegbeschreibung folgt dabei ein Schritt dem anderen in einer festgelegten Reihenfolge. Die korrekte und vollständige Ausführung aller Schritte ist entscheidend - das Auslassen oder Vertauschen von Anweisungen führt in der Regel nicht zum gewünschten Ergebnis.</p>
<p>Sowohl Menschen als auch Computer verarbeiten Anweisungen standardmäßig sequentiell - also Schritt für Schritt von oben nach unten. Diese intuitive Vorgehensweise bildet die Grundlage für das Verständnis von Algorithmen. Allerdings können Algorithmen auch komplexere Strukturen enthalten, die von diesem linearen Ablaufmuster abweichen und alternative Ausführungspfade ermöglichen.</p>
</section>
<section id="verzweigungen" class="level3" data-number="2.4.2">
<h3 data-number="2.4.2" class="anchored" data-anchor-id="verzweigungen"><span class="header-section-number">2.4.2</span> Verzweigungen</h3>
<p>Verzweigungen stellen eine grundlegende Form der nicht-linearen Ausführung eines Algorithmus dar. Sie ermöglichen es, dass der Algorithmus basierend auf bestimmten Bedingungen unterschiedliche Ausführungspfade einschlägt. Eine Verzweigung führt also je nach erfüllter oder nicht erfüllter Bedingung zu verschiedenen Anweisungsfolgen. Ein alltägliches Beispiel findet sich in Kochrezepten: “Wenn der Teig zu flüssig ist, füge mehr Mehl hinzu”. Die Anweisung, mehr Mehl hinzuzufügen, wird nur dann ausgeführt, wenn die Bedingung “Teig ist zu flüssig” zutrifft. Ist der Teig bereits von idealer Konsistenz, wird diese Anweisung übersprungen.</p>
</section>
<section id="iterationen" class="level3" data-number="2.4.3">
<h3 data-number="2.4.3" class="anchored" data-anchor-id="iterationen"><span class="header-section-number">2.4.3</span> Iterationen</h3>
<p>Ein Beispiel für ein iteratives, schrittweise Vorgehen ist das Babylonische Wurzelziehen aus <a href="#sec-babylonian" class="quarto-xref"><span>Kapitel 2.3.1.2</span></a>.</p>
</section>
<section id="kapselung" class="level3" data-number="2.4.4">
<h3 data-number="2.4.4" class="anchored" data-anchor-id="kapselung"><span class="header-section-number">2.4.4</span> Kapselung</h3>
<p>Kapselung beschreibt das Prinzip, komplexe Algorithmen in kleinere, überschaubare Einheiten zu zerlegen. Diese Modularisierung erhöht nicht nur die Lesbarkeit und Wartbarkeit des Algorithmus, sondern ermöglicht auch die Wiederverwendung von Teilfunktionen in anderen Kontexten. Ein klassisches Beispiel ist die Auslagerung häufig benötigter Berechnungen in separate Funktionen, die dann an verschiedenen Stellen aufgerufen werden können.</p>
</section>
<section id="rekursion" class="level3" data-number="2.4.5">
<h3 data-number="2.4.5" class="anchored" data-anchor-id="rekursion"><span class="header-section-number">2.4.5</span> Rekursion</h3>
<p>Rekursion ist ein mächtiges algorithmisches Konzept, bei dem sich ein Algorithmus selbst aufruft, um ein Problem zu lösen. Dieses Prinzip eignet sich besonders gut für Probleme, die sich in kleinere, gleichartige Teilprobleme zerlegen lassen. Ein klassisches Beispiel ist die Berechnung der Fakultät einer Zahl, bei der sich die Lösung aus der Multiplikation mit der Fakultät der nächstkleineren Zahl ergibt. Aber auch die binäre Suche kann rekursiv implementiert werden, indem der Algorithmus den zu durchsuchenden Bereich in der Mitte teilt und sich selbst mit der relevanten Hälfte aufruft. Diese rekursive Struktur macht den Algorithmus nicht nur elegant, sondern auch besonders effizient.</p>
</section>
</section>
<section id="was-sind-herausforderungen-bei-der-fomulierung-von-algorithmen" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="was-sind-herausforderungen-bei-der-fomulierung-von-algorithmen"><span class="header-section-number">2.5</span> Was sind Herausforderungen bei der Fomulierung von Algorithmen?</h2>
<section id="sec-algo-halt" class="level3" data-number="2.5.1">
<h3 data-number="2.5.1" class="anchored" data-anchor-id="sec-algo-halt"><span class="header-section-number">2.5.1</span> Haltekriterium</h3>
<p>Ein wichtiges Kriterium bei der Formulierung von Algorithmen ist die Bestimmung eines geeigneten Haltekriteriums. Das Haltekriterium definiert die Bedingung, unter der ein Algorithmus seine Ausführung beendet und ein Ergebnis zurückliefert. Beim Babylonischen Wurzelziehen beispielsweise ist das Haltekriterium erreicht, wenn die Differenz zwischen zwei aufeinanderfolgenden Näherungswerten einen bestimmten Schwellenwert unterschreitet.</p>
<p>Die Bestimmung eines geeigneten Haltekriteriums stellt für manche Algorithmen eine besondere Herausforderung dar. Dies zeigt sich besonders deutlich bei Optimierungsalgorithmen, wo die Frage nach dem optimalen Zeitpunkt für die Beendigung des Algorithmus nicht trivial ist. Da das theoretische Optimum in der Regel unbekannt ist, lässt sich schwer einschätzen, wie nah die aktuelle Lösung bereits am bestmöglichen Ergebnis liegt. Eine pragmatische Lösung für dieses Problem besteht in der Festlegung eines Optimierungsbudgets, das die maximale Anzahl der Durchläufe definiert, die der Algorithmus ausführen darf.</p>
</section>
<section id="sec-algo-infinity" class="level3" data-number="2.5.2">
<h3 data-number="2.5.2" class="anchored" data-anchor-id="sec-algo-infinity"><span class="header-section-number">2.5.2</span> Endlosschleifen</h3>
<p>Endlosschleifen stellen eine kritische Herausforderung bei der Entwicklung von Algorithmen dar. Sie entstehen, wenn ein Algorithmus das definierte Haltekriterium nie erreicht und stattdessen kontinuierlich dieselben Anweisungen wiederholt. Ein typisches Beispiel ist eine While-Schleife, deren Bedingung permanent wahr bleibt - der Algorithmus verbleibt dann in einem unendlichen Ausführungszyklus. Ohne geeignete Fehlerbehandlung führt dies meist zu einem Programmabsturz, da Systemressourcen wie Arbeitsspeicher oder Prozessorzeit erschöpft werden.</p>
</section>
<section id="beurteilung-des-ergebnisses" class="level3" data-number="2.5.3">
<h3 data-number="2.5.3" class="anchored" data-anchor-id="beurteilung-des-ergebnisses"><span class="header-section-number">2.5.3</span> Beurteilung des Ergebnisses</h3>
<p>Die Beurteilung der Qualität eines algorithmischen Ergebnisses ist nicht immer eindeutig und hängt stark vom jeweiligen Anwendungsfall ab. Bei numerischen Berechnungen lässt sich die Genauigkeit oft durch den Vergleich mit bekannten Referenzwerten oder theoretischen Grenzen bestimmen. Bei Optimierungsproblemen hingegen ist die Bewertung komplexer, da das theoretische Optimum häufig unbekannt ist und die Qualität der Lösung von verschiedenen, teils konkurrierenden Kriterien abhängt.</p>
</section>
<section id="erklärbarkeit-des-ergebnisses" class="level3" data-number="2.5.4">
<h3 data-number="2.5.4" class="anchored" data-anchor-id="erklärbarkeit-des-ergebnisses"><span class="header-section-number">2.5.4</span> Erklärbarkeit des Ergebnisses</h3>
<p>Die Erklärbarkeit algorithmischer Entscheidungen spielt eine zentrale Rolle in der modernen Informatik, besonders in kritischen Bereichen wie der Medizin oder Rechtsprechung. Dabei stellt die mangelnde Transparenz komplexer Algorithmen eine fundamentale Herausforderung dar: Der Prozess von der Eingabe bis zur Entscheidungsfindung ist oft nicht direkt nachvollziehbar. Dieses Problem manifestiert sich besonders deutlich bei Deep Learning Modellen, deren mehrschichtige Strukturen und komplexe Berechnungen eine intuitive Interpretation der Entscheidungswege erschweren. Die Entwicklung von Methoden zur besseren Erklärbarkeit dieser “Black Box”-Systeme ist daher ein aktives Forschungsfeld, das darauf abzielt, die Akzeptanz und Vertrauenswürdigkeit algorithmischer Entscheidungen zu erhöhen.</p>
</section>
</section>
<section id="gibt-es-bessere-und-schlechtere-algorithmen" class="level2" data-number="2.6">
<h2 data-number="2.6" class="anchored" data-anchor-id="gibt-es-bessere-und-schlechtere-algorithmen"><span class="header-section-number">2.6</span> Gibt es bessere und schlechtere Algorithmen?</h2>
<section id="komplexität" class="level3" data-number="2.6.1">
<h3 data-number="2.6.1" class="anchored" data-anchor-id="komplexität"><span class="header-section-number">2.6.1</span> Komplexität</h3>
<p>Die Komplexität eines Algorithmus beschreibt, wie sich sein Ressourcenbedarf (meist Zeit und Speicher) in Abhängigkeit von der Eingabegröße entwickelt. Diese mathematische Charakterisierung ermöglicht einen objektiven Vergleich verschiedener algorithmischer Lösungen für dasselbe Problem. Besonders wichtig ist dabei die asymptotische Komplexität, die das Verhalten des Algorithmus für große Eingabemengen beschreibt.</p>
</section>
<section id="verständlichkeit" class="level3" data-number="2.6.2">
<h3 data-number="2.6.2" class="anchored" data-anchor-id="verständlichkeit"><span class="header-section-number">2.6.2</span> Verständlichkeit</h3>
<p>Die Verständlichkeit eines Algorithmus ist ein weiteres wichtiges Qualitätsmerkmal. Ein gut strukturierter und dokumentierter Algorithmus erleichtert nicht nur die Wartung und Weiterentwicklung, sondern reduziert auch die Wahrscheinlichkeit von Fehlern bei der Implementierung. Dabei spielt die Wahl aussagekräftiger Bezeichner und eine klare Dokumentation der einzelnen Schritte eine zentrale Rolle.</p>
</section>
</section>
<section id="übungsaufgaben" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="übungsaufgaben">Übungsaufgaben</h2>
<ol type="1">
<li><p>Woher stammt der Begriff “Algorithmus”?</p></li>
<li><p>Definiere, was ein Algorithmus ist, und gib drei Beispiele für Algorithmen aus dem Alltag, die keinen direkten Bezug zu Computern haben.</p></li>
<li><p>Beobachte eine Woche lang Algorithmen in deinem Alltag (z.B. Navigationssysteme, Empfehlungssysteme, Suchmaschinen). Dokumentiere deren Eingaben, Verarbeitung und Ausgaben.</p></li>
<li><p>Welche grundlegenden Ansätze zur Klassifizierung von Algorithmen gibt es?</p></li>
<li><p>Erläutere, was mit der Komplexität eines Algorithmus gemeint ist. Warum ist die Komplexität eines Algorithmus wichtig? Wie wird sie angegeben?</p></li>
<li><p>Welche Komplexitätsklassen kennst du? Bringe sie in eine Reihenfolge von der geringsten zur höchsten Komplexität.</p></li>
<li><p>Vergleiche die Laufzeitkomplexität von linearer und binärer Suche anhand eines konkreten Beispiels mit einer Million sortierten Zahlen!</p></li>
<li><p>Berechne den größten gemeinsamen Teiler der Zaheln 56 und 98 mithilfe des euklidischen Algorithmus! Dokumentiere jeden Schritt!</p></li>
<li><p>Wir haben exemplarisch für einen Algorithmus die babylonische Methode zur Approximation einer Quadratwurzel kennengelernt. Beantworte die nachfolgenden Fragen in diesem Kontext:</p>
<ol type="a">
<li>Berechne die Quadratwurzel von 25 mit der babylonischen Methode und dokumentiere jeden Schritt! Wähle einen sinnvollen Startwert!</li>
<li>Vergleiche die Ergebnisse der babylonischen Methode nach 3, 5 und 7 Iterationen mit dem exakten Wert der Quadratwurzel.</li>
<li>Erkläre die Funktionsweise des babylonischen Algorithmus zur Berechnung der Quadratwurzel. Verwende dazu visuelle Hilfsmittel. Warum konvergiert der Algorithmus gegen den exakten Wert der Quadratwurzel?</li>
</ol></li>
<li><p>Erläutere die Monte-Carlo-Methode zur Schätzung von <span class="math inline">\(\pi\)</span> und erkläre, wie man mithilfe von Zufallszahlen eine Annäherung an <span class="math inline">\(\pi\)</span> erreichen kann.</p></li>
<li><p>Erkläre den Unterschied zwischen einem stochastischen und einem deterministischen Algorithmus anhand eines selbst gewählten Beispiels.</p></li>
<li><p>Finde weitere Probleme, die sich durch Monte-Carlo-Simulationen lösen lassen. Weshalb sind manche dieser Probleme mit anderen Methoden nicht lösbar?</p></li>
<li><p>Du hast zwei Sanduhren: Eine läuft 4 Minuten, die andere 7 Minuten. Wie kannst du damit genau 9 Minuten messen? Entwickle einen präzisen Algorithmus für das Problem!</p></li>
<li><p>Du hast drei Gefäße mit 3, 5 und 8 Litern Fassungsvermögen. Das 8-Liter-Gefäß ist voll, die anderen sind leer. Entwickle einen Algorithmus, um genau 4 Liter abzumessen!</p></li>
<li><p>Entwickle einen Algorithmus, der prüft ob eine eingegebene Zahl eine Primzahl ist. Stelle den Algorithmus als Flussdiagramm dar!</p></li>
<li><p>Recherchiere einen Fall, bei dem ein algorithmisches System zu problematischen Entscheidungen geführt hat. Analysiere die Ursachen und schlage Möglichkeiten zur Verbesserung!</p></li>
<li><p>Diskutiert die ethischen Implikationen von nicht-erklärbaren algorithmischen Entscheidungen in kritischen Bereichen wie Medizin oder Rechtsprechung! In welchen Bereichen könnte eine fehlende Erklärbarkeit noch kritisch sein?</p></li>
</ol>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-adami_what_2016" class="csl-entry" role="listitem">
Adami, Christoph. 2016. <span>„What is <span>Information</span>?“</span> <em>Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences</em> 374 (2063): 20150230. <a href="https://doi.org/10.1098/rsta.2015.0230">https://doi.org/10.1098/rsta.2015.0230</a>.
</div>
<div id="ref-brookshear_computer_2020" class="csl-entry" role="listitem">
Brookshear, J. Glenn, und Dennis Brylow. 2020. <em>Computer science: an overview</em>. 13th edition, global edition. NY, NY: Pearson.
</div>
<div id="ref-petzold_code_2022" class="csl-entry" role="listitem">
Petzold, Charles. 2022. <em>Code: the hidden language of computer hardware and software</em>. 2. Aufl. Hoboken: Microsoft Press.
</div>
<div id="ref-polya" class="csl-entry" role="listitem">
Pólya, George, und John Horton Conway. 2004. <em>How to solve it: a new aspect of mathematical method</em>. Expanded Princeton Science Library ed. Princeton science library. Princeton [N.J.]: Princeton University Press.
</div>
<div id="ref-scott_but_2009" class="csl-entry" role="listitem">
Scott, John C. 2009. <em>But how do it know?: the basic principles of computers for everyone</em>. Oldsmar, FL: John C. Scott.
</div>
</div>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Kopiert");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Kopiert");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./problem-solving.html" class="pagination-link" aria-label="Problemlösung">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Problemlösung</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./part-representation.html" class="pagination-link" aria-label="Repräsentation">
        <span class="nav-page-text">Repräsentation</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>
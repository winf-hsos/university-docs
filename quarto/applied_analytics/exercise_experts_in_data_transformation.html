<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Übung: Experten der Datentransformation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="exercise_experts_in_data_transformation_files/libs/clipboard/clipboard.min.js"></script>
<script src="exercise_experts_in_data_transformation_files/libs/quarto-html/quarto.js"></script>
<script src="exercise_experts_in_data_transformation_files/libs/quarto-html/popper.min.js"></script>
<script src="exercise_experts_in_data_transformation_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="exercise_experts_in_data_transformation_files/libs/quarto-html/anchor.min.js"></script>
<link href="exercise_experts_in_data_transformation_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="exercise_experts_in_data_transformation_files/libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="exercise_experts_in_data_transformation_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="exercise_experts_in_data_transformation_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="exercise_experts_in_data_transformation_files/libs/bootstrap/bootstrap-8a79a254b8e706d3c925cde0a310d4f0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Übung: Experten der Datentransformation</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>In dieser Übung werden alle Studierenden im Modul einer von 4 Gruppen zugeordnet. Jede Gruppe hat die Aufgabe, sich im Selbststudium auf eine der vier Arten der Datentransformation zu spezialisieren:</p>
<ol type="1">
<li><p>Auswahl von Spalten mit <code>select</code></p></li>
<li><p>Filtern von Zeilen mit <code>filter</code></p></li>
<li><p>Veränderung bestehender Spalten und Hinzufügen neuer Spalten mit <code>mutate</code> und <code>transmute</code></p></li>
<li><p>Gruppierung und Zusammenfassung von Zeilen mit <code>group_by</code> und <code>summarize</code></p></li>
</ol>
<section id="gruppe-a-expertinnen-für-select" class="level3">
<h3 class="anchored" data-anchor-id="gruppe-a-expertinnen-für-select">Gruppe A: Expert*innen für <code>select</code></h3>
<p>Ihr werdet euch intensiv mit dem Auswählen von Spalten mittels der <code>select</code>-Funktion aus dem <code>{dplyr}</code>-Paket befassen. Konzentriert euch dabei besonders auf die folgenden Aspekte:</p>
<ul>
<li><p>Wie verschafft man sich einen Überblick über verfügbare Spalten?</p></li>
<li><p>Wie wählt man Spalten anhand ihres Namens aus?</p></li>
<li><p>Wie kann man effizient nach Namensmustern suchen und auswählen?</p></li>
<li><p>Wie kann man Spalten <em>ausschließen</em> (abwählen) anstatt auszuwählen?</p></li>
<li><p>Ist es möglich, Spalten nach ihrem Datentyp zu selektieren?</p></li>
<li><p>Wie funktioniert die Auswahl anhand der Position einer Spalte?</p></li>
<li><p>Kann man Spalten anhand der Definition einer Menge mit der <code>c()</code>-Funktion auswählen?</p></li>
</ul>
<p><strong>Eure Aufgabe</strong>: Überlegt, wie ihr eure gewonnenen Erkenntnisse zum Auswählen von Spalten am besten euren Kommiliton*innen vermitteln könnt. Nutzt dazu anschauliche Codebeispiele anhand eines Datensatzes eurer Wahl. Achtet darauf, dass der gewählte Datensatz eure Beispiele unterstützt. Ihr könnt auch visuelle Hilfsmittel wie Folien oder Flipcharts verwenden. Ihr habt insgesamt 30 Minuten Zeit, um eure Ergebnisse zu präsentieren.</p>
</section>
<section id="gruppe-b-expertinnen-für-filter" class="level3">
<h3 class="anchored" data-anchor-id="gruppe-b-expertinnen-für-filter">Gruppe B: Expert*innen für <code>filter</code></h3>
<p>Ihr werdet euch intensiv mit dem Filtern von Zeilen mittels der <code>filter</code>-Funktion aus dem <code>dplyr</code>-Paket auseinandersetzen. Fokussiert euch dabei insbesondere die folgenden Teilaspekte:</p>
<ul>
<li><p>Wie kann man auf Basis einfacher Vergleiche filtern?</p></li>
<li><p>Auf welche Weise kann man numerische Werte filtern?</p></li>
<li><p>Kann man auf Basis einer Zugehörigkeit zu einer Menge filtern?</p></li>
<li><p>Wie erzeuge ich komplexe Filterbedingungen mit logischen Verknüpfungen?</p></li>
<li><p>Wie finde und entferne ich fehlende Werte?</p></li>
<li><p>Wie kann ich Filterbedingungen verneinen?</p></li>
<li><p>Kann ich auch in unstrukturierten Texte suchen und danach Filtern?</p></li>
</ul>
<p><strong>Eure Aufgabe:</strong> Überlegt euch, wie ihr die gewonnenen Erkenntnisse zum Aus- oder Abwählen von Zeilen am einfachsten euren Kommiliton*innen erklären könnt. Nutzt dafür anschauliche Codebeispiele anhand eines Datensatzes eurer Wahl. Stellt sicher, dass der gewählte Datensatz eure Beispiele unterstützt. Auch visuelle Hilfsmittel wie Slides oder Flipcharts sind erlaubt. Ihr bekommt insgesamt 30 Minuten für die Vorstellung eurer Ergebnisse.</p>
</section>
<section id="gruppe-c-expertinnen-für-mutate-und-transmute" class="level3">
<h3 class="anchored" data-anchor-id="gruppe-c-expertinnen-für-mutate-und-transmute">Gruppe C: Expert*innen für <code>mutate</code> und <code>transmute</code></h3>
<p>Ihr steigt tief in das Verändern bestehender und das Erzeugen neuer, berechneter Spalten mittels der <code>mutate</code>- oder <code>transmute</code>-Funktion aus dem <code>dplyr</code>-Paket ein. Schaut euch dabei insbesondere die folgenden Teilaspekte genauer an:</p>
<ul>
<li><p>Wie kann ich einfache berechnete Spalten erzeugen?</p></li>
<li><p>Wie kann ich Bestandteile eines Datumswerts in eine neue Spalte extrahieren (z. B. nur das Jahr)?</p></li>
<li><p>Wie kann ich bestimmen, an welcher Stelle eine neue Spalte eingefügt wird?</p></li>
<li><p>Wie erreiche ich es, dass nur die neuen Spalten im Ergebnis erhalten bleiben?</p></li>
<li><p>Wie erreiche ich es, dass neben der neuen auch die in der Berechnung verwendeten Spalten im Ergebnis erhalten bleiben?</p></li>
<li><p>Wie kann ich den Datentyp existierender Spalten verändern?</p></li>
<li><p>Wie kann ich eine Spalte umbenennen?</p></li>
</ul>
<p><strong>Eure Aufgabe:</strong> Überlegt euch, wie ihr die gewonnenen Erkenntnisse zum Verändern oder Neuhinzufügen von Spalten am einfachsten euren Kommiliton*innen erklären könnt. Nutzt dafür anschauliche Codebeispiele anhand eines Datensatzes eurer Wahl. Stellt sicher, dass der gewählte Datensatz eure Beispiele unterstützt. Auch visuelle Hilfsmittel wie Slides oder Flipcharts sind erlaubt. Ihr bekommt insgesamt 30 Minuten für die Vorstellung eurer Ergebnisse.</p>
</section>
<section id="gruppe-d-expertinnen-für-group_by-und-summarize" class="level3">
<h3 class="anchored" data-anchor-id="gruppe-d-expertinnen-für-group_by-und-summarize">Gruppe D: Expert*innen für <code>group_by</code> und <code>summarize</code></h3>
<p>Ihr seid für die letzte Form der Datentransformation zuständig und studiert die Möglichkeiten, Daten mithilfe von Funktionen aus dem <code>dplyr</code>-Paket zu gruppieren und zusammenzufassen. Beleuchtet dabei insbesondere die folgenden Teilaspekte genauer:</p>
<ul>
<li><p>Wie kann man einfache Aggregationen, wie die Summe einer Spalte über alle Einträge oder die Anzahl Datensätze insgesamt, erstellen?</p></li>
<li><p>Wie gruppiere ich meine Daten nach einem Merkmal und berechne anschließend eine aggregierte Kennzahl wie den Durchschnitt oder die Summe?</p></li>
<li><p>Wie berechne ich die relative Häufikeit für jede Gruppe, zum Beispiel den prozentualen Anteil pro Geschlecht?</p></li>
<li><p>Was machen die Funktionen <code>distinct</code>, <code>count</code> und <code>tally</code>?</p></li>
<li><p>Wie kann ich schnell eine Übersicht über die häufigsten Werte einer nominal skalierten Variable bekommen?</p></li>
<li><p>Was macht die <code>tabyl</code>-Funktion aus dem <code>janitor</code>-Paket?</p></li>
</ul>
<p><strong>Eure Aufgabe:</strong> Überlegt euch, wie ihr die gewonnenen Erkenntnisse zum Gruppieren und Zusammenfassen von Zeilen am einfachsten euren Kommiliton*innen erklären könnt. Nutzt dafür anschauliche Codebeispiele anhand eines Datensatzes eurer Wahl. Stellt sicher, dass der gewählte Datensatz eure Beispiele unterstützt. Auch visuelle Hilfsmittel wie Slides oder Flipcharts sind erlaubt. Ihr bekommt insgesamt 30 Minuten für die Vorstellung eurer Ergebnisse.</p>
</section>
<section id="hilfsmittel" class="level3">
<h3 class="anchored" data-anchor-id="hilfsmittel">Hilfsmittel</h3>
<p>Sucht nach eigenen Quellen, die euch am besten weiterhelfen, und teilt am Ende eurer Einführung eine kleine Linkliste mit euren Kommiliton*innen. Schaut aber unbedingt auch hier vorbei:</p>
<ul>
<li><p>Wickham, Hadley, et al.&nbsp;R for Data Science: Import, Tidy, Transform, Visualize, and Model Data. 2nd edition, O’Reilly Media, Inc, 2023 (<a href="https://r4ds.hadley.nz/">Online frei verfügbar</a>).</p></li>
<li><p><a href="https://dplyr.tidyverse.org/">Offizielle Webseite des <code>dplyr</code>-Pakets</a></p></li>
<li><p><a href="https://chat.openai.com/">ChatGPT von OpenAI</a></p></li>
</ul>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Kopiert");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Kopiert");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>